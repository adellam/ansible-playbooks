# This is a basic VCL configuration file for varnish.  See the vcl(7)
# man page for details on VCL syntax and semantics.
# 
# Default backend definition.  Set this to point to your content
# server.
#
vcl 4.0;
import directors;
import std;
#
# Generic probe used by all the backends
probe healthcheck {
      .url = "/index.php";
      .interval = 250ms;
      .timeout = 10s;
      .window = 1;
      .threshold = 1;
}

#
# Application backends
# They are also a fallback for the static content
#
backend a5_dev {
    .host = "127.0.0.1";
    .port = "80";
    .probe = healthcheck;
    .connect_timeout = {{ varnish_static_c_timeout }};
    .first_byte_timeout = {{ varnish_static_first_byte_timeout }};
    .between_bytes_timeout = {{ varnish_static_between_bytes_timeout }};
    .max_connections = {{ varnish_static_max_connections }};
}

sub vcl_init {
    new a5dev_cluster = directors.hash();
    a5dev_cluster.add_backend(a5_dev, 1.0);

    new a5admin_cluster = directors.fallback();
    a5admin_cluster.add_backend(a5_dev);
}


# Respond to incoming requests.
sub vcl_recv {
    # Add a unique header containing the client address
    # NB: it's the default, no need to explicitly add the X-Forwarded-For header
#    unset req.http.X-Forwarded-For;
#    set    req.http.X-Forwarded-For = client.ip;
    if (req.url ~ "^/backend/" || req.url ~ "^/admin(.*)" || req.url ~ "(?i)\.gupld" ) {
         set req.backend_hint = a5admin_cluster.backend();
       	 return(pipe);
    }
    if (req.url ~ "^/cloud-assets/" && !req.url ~ "(?i)\.nocache\.(.*)" ) {
         set req.backend_hint = a5dev_cluster.backend(client.identity);
         unset req.http.Cookie;
    }
    else {
         set req.backend_hint = a5dev_cluster.backend(client.identity);
    }

    # Always cache the following file types for all users.
    if (req.url ~ "(?i)\.(avi|mpeg|webm|vorbis|vob|mp4|divx|mp3|flac|ogg|ogv|png|gif|jpeg|jpg|ico|swf|css|js|html|htm)(\?[a-z0-9]+)?$" && !req.url ~ "(?i)\.nocache\.(.*)") {
       unset req.http.Cookie;
#       return(hash);
    }
    # Handle compression correctly. Different browsers send different
    # "Accept-Encoding" headers, even though they mostly all support the same
    # compression mechanisms. By consolidating these compression headers into
    # a consistent format, we can reduce the size of the cache and get more hits.
    # @see: http:// varnish.projects.linpro.no/wiki/FAQ/Compression
    if (req.http.Accept-Encoding) {
       if (req.http.Accept-Encoding ~ "gzip") {
       	  # If the browser supports it, we'll use gzip.
       	  set req.http.Accept-Encoding = "gzip";
       }
       else if (req.http.Accept-Encoding ~ "deflate") {
       	  # Next, try deflate if it is supported.
	  set req.http.Accept-Encoding = "deflate";
       }
       else {
       	     # Unknown algorithm. Remove it and send unencoded.
    	     unset req.http.Accept-Encoding;
       }
    }
}

# Code determining what to do when serving items from the backend servers.
sub vcl_backend_response {
    if (beresp.http.X-No-Cache) {
        set beresp.uncacheable = true;
        set beresp.ttl = 120s;
        return (deliver);
    }
    set beresp.http.X-Backend = beresp.backend.name;
# Don't cache all errors
    if(beresp.status >= 300 && beresp.status <= 399) {
         set beresp.ttl = 5m;
    }
    if(beresp.status >= 399 && beresp.status <= 403) {
         set beresp.uncacheable = true;
         set beresp.ttl = 10s;
	 return(deliver);
    }
    if (beresp.status == 404) {
         set beresp.ttl = 30m;
    }   
    if (beresp.status >= 405) {
         set beresp.uncacheable = true;
         set beresp.ttl = 0s;
	 return(deliver);
    }
    if (beresp.http.Content-Length && beresp.http.Content-Length ~ "^[0-9]$") {
   	 #log "TooSmall: Pass on ( " req.url " ) small objects: " beresp.http.Content-Length ;
         set beresp.uncacheable = true;
         unset beresp.http.expires;
         set beresp.ttl = 0s;
 	 return(deliver);
    }
    if(bereq.url == "/robots.txt") {
         # Robots.txt is updated rarely and should be cached for a lot of time
         # Ban manually as required
         set beresp.ttl = 1d;
    }
    if ((bereq.url ~ "^/cloud-assets/" || bereq.url ~ "(?i)\.(avi|mpeg|webm|vorbis|vob|mp4|divx|mp3|flac|ogg|ogv|png|gif|jpeg|jpg|ico|swf|css|js|html|htm)(\?[a-z0-9]+)?$") && !bereq.url ~ "(?i)\.nocache\.(.*)") {
         unset beresp.http.expires;
       	 unset beresp.http.set-cookie;
	 /* Set the clients TTL on this object */
         set beresp.http.cache-control = "max-age=604800";
         /* marker for vcl_deliver to reset Age: */
         set beresp.http.magicmarker = "1";
	 set beresp.ttl = 6w;
    }
    set beresp.grace = 6h;
}

sub vcl_hit {
    if (obj.ttl >= 0s) {
         // A pure unadultered hit, deliver it
         return (deliver);
    }
    if (!std.healthy(req.backend_hint) && (obj.ttl + obj.grace > 0s)) {
         return (deliver);
    } else {
         return (fetch);
    }
}

sub vcl_deliver {
    if (resp.http.magicmarker) {
        /* Remove the magic marker */
	unset resp.http.magicmarker;

	/* By definition we have a fresh object */
	set resp.http.age = "0";
	}
}

sub vcl_pipe {
    # http://www.varnish-cache.org/ticket/451
    # This forces every pipe request to be the first one.
    set bereq.http.connection = "close";
}
